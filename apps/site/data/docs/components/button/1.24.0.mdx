---
title: Button
description: A simple button component
name: button
component: Button
package: button
demoName: Button
---

# Button

<Description>A simple, sizable button.</Description>

<HeroContainer demoMultiple>
  <ButtonDemo />
</HeroContainer>

```tsx hero template=Button

```

<Highlights
  features={[
    'Accepts size prop that works on all styles.',
    'Can inverse theme with themeInverse.',
    'Place an icon before or after.',
  ]}
/>

## Anatomy

```tsx
import { Button } from 'tamagui'
import { ArrowLeft } from '@tamagui/lucide-icons'

// Simple API
export default () => (
  <Button icon={<ArrowLeft />}>Lorem ipsum</Button>
)

// Composable API
export default () => (
  <Button>
    <Button.Text>Lorem ipsum</Button.Text>
    <Button.Icon>
      <ArrowLeft />
    </Button.Icon>
  </Button>
)
```

## Configuration

The button component comes with two APIs, `composable` and `simple`. The simple API is very easy to use but harder to customize, while the composable API gives you more control over customization with the price of verbosity.

By default, both APIs are enabled at the cost of Tamagui double-rendering to figure out which one you're using.

To prevent that, you should set the `buttonApi` option when calling `createTamagui`, like so:

```ts
createTamagui({
  // ...the rest of your config
  buttonApi: 'composable', // or 'simple'
})
```

## Headless

Tamagui also offers headless Button with no styles included. Import it from `@tamagui/button/headless`.

<HeroContainer demoMultiple>
  <ButtonHeadlessDemo />
</HeroContainer>

```tsx hero template=ButtonHeadless

```

## API Reference (Simple)

### Button

Buttons extend Stack views inheriting all the [Tamagui standard props](/docs/intro/props), plus:

<PropsTable
  data={[
    {
      name: 'size',
      required: false,
      type: 'string | tokens.size',
      description: `Set a size, number or one of the size token values.`,
    },
    {
      name: 'theme',
      required: false,
      type: 'string',
      description: `Apply a theme just to the button and it's children`,
    },
    {
      name: 'themeInverse',
      required: false,
      type: 'boolean',
      description: `Helpful for "flipping" any theme between dark and light (including flipping a sub themes defined as [subtheme]-[dark/light]`,
    },
    {
      name: 'noTextWrap',
      required: false,
      type: 'boolean',
      description: `If true, Button won't wrap content with a Text element.`,
    },
    {
      name: 'icon',
      required: false,
      type: 'JSX.Element',
      description: `Pass any React element, appears before the text.`,
    },
    {
      name: 'iconAfter',
      required: false,
      type: 'JSX.Element',
      description: `Pass any React element, appears after the text.`,
    },
    {
      name: 'scaleIcon',
      required: false,
      type: 'number',
      description: `Scale the icon more than usual by this number.`,
    },
    {
      name: 'scaleSpace',
      required: false,
      type: 'number',
      description: `Scale the spacing more than usual by this number.`,
    },
    {
      name: 'spaceFlex',
      required: false,
      type: `boolean`,
      description: `Makes all space elements have a flex.`,
    },
    {
      name: 'color',
      required: false,
      type: `SizableTextProps['color']`,
      description: `Passes "color" down to the inner text component`,
    },
    {
      name: 'fontWeight',
      required: false,
      type: `SizableTextProps['fontWeight']`,
      description: `Passes "fontWeight" down to the inner text component`,
    },
    {
      name: 'letterSpacing',
      required: false,
      type: `SizableTextProps['letterSpacing']`,
      description: `Passes "letterSpacing" down to the inner text component`,
    },
    {
      name: 'textAlign',
      required: false,
      type: `SizableTextProps['textAlign']`,
      description: `Passes "textAlign" down to the inner text component`,
    },
    {
      name: 'circular',
      required: false,
      type: `boolean`,
      description: `Forces a circular button.`,
    },
    {
      name: 'unstyled',
      required: false,
      type: `boolean`,
      description: `Removes all default Tamagui styles.`,
    },
  ]}
/>

## API Reference (Composable)

Headless buttons have a similar API to this.

### Button

Buttons extend Stack views inheriting all the [Tamagui standard props](/docs/intro/props).

### Button.Text

Button.Text extends [`SizableText`](/docs/components/text#sizabletext)

### Button.Icon

You can pass an icon as this component's children and it'll automatically pass `size` and `color` to your icon based on the current theme.

## Examples

### Sizing

Sizing buttons provides a unique challenge especially for a compiler, because you need to adjust many different properties - not just on the outer frame, but on the text wrapped inside. Tamagui supports adjusting the padding, border radius, font size and icons sizes all in one with the `size` prop.

```tsx
import { Button } from 'tamagui'

// Simple API
export default () => (
  <Button size="$6">Lorem ipsum</Button>
)

// Composable API
export default () => (
  <Button size="$6">
    <Button.Text>Lorem ipsum</Button.Text>
  </Button>
)
```

Given your theme defines a size `6`, the button will adjust all of the properties appropriately. You can also pass a plain number to get an arbitrary size.

### Advanced Customization With Simple API

<Notice>
  The simple API's advanced customization is deprecated. If you require advanced
  customization, we recommend using [Headless](#headless) or
  [Composable](#api-reference-composable) buttons.
</Notice>

Button only supports a limited subset of text props directly, and doesn't accept `hoverStyle` text props. If you need more control, you can do a simple customization using some exported helpers.

Please note that this pattern is a bit antithetical to the multiple-components APIs that Tamagui generally prefers. In a future release we hope to fix this, but that change should be easy to migrate to.

```tsx
import { forwardRef } from 'react'
import {
  ButtonFrame,
  ButtonText,
  GetProps,
  ButtonProps as TamaguiButtonProps,
  styled,
  themeable,
  useButton,
} from 'tamagui'

const CustomButtonFrame = styled(ButtonFrame, {
  // ...
})

const CustomButtonText = styled(ButtonText, {
  // ...
})

// to capture the custom variant types you define
type CustomButtonFrameProps = GetProps<typeof CustomButtonFrame>
type CustomButtonTextProps = GetProps<typeof CustomButtonText>

export type CustomButtonProps = TamaguiButtonProps &
  CustomButtonFrameProps &
  CustomButtonTextProps

export const Button = CustomButtonFrame.styleable<CustomButtonProps>((propsIn, ref) => {
  const { props } = useButton(propsIn, { Text: CustomButtonText })
  return <CustomButtonFrame {...props} ref={ref} />
})
```
